{"version":3,"sources":["index.js"],"names":["EventBus","events","eventType","func","context","push","args","event","length","map","obj","apply","reduceRight","prev","current"],"mappings":";AA+HK,aAAA,SAAA,EAAA,EAAA,GAAA,KAAA,aAAA,GAAA,MAAA,IAAA,UAAA,qCAAA,SAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,OAAA,IAAA,CAAA,IAAA,EAAA,EAAA,GAAA,EAAA,WAAA,EAAA,aAAA,EAAA,EAAA,cAAA,EAAA,UAAA,IAAA,EAAA,UAAA,GAAA,OAAA,eAAA,EAAA,EAAA,IAAA,IAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,GAAA,EAAA,EAAA,UAAA,GAAA,GAAA,EAAA,EAAA,GAAA,EAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAjHgBA,IAAAA,EAiHhB,WAhHa,SAAA,IAAA,EAAA,KAAA,GACLC,KAAAA,OAAS,GA+GjB,OAAA,EAAA,EAAA,CAAA,CAAA,IAAA,KArFEC,MAAAA,SAAAA,EAAWC,GAAMC,IAAAA,EAAU,UAAA,OAAA,QAAA,IAAA,UAAA,GAAA,UAAA,GAAA,KACrB,KAAKH,OAAOC,KACRD,KAAAA,OAAOC,GAAa,IAExBD,KAAAA,OAAOC,GAAWG,KAAK,CAAEF,KAAAA,EAAMC,QAAAA,MAiFvC,CAAA,IAAA,UAjEOF,MAAAA,SAAAA,GAAcI,IAAAA,IAAAA,EAAAA,UAAAA,OAAAA,EAAM,IAAA,MAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,IAANA,EAAM,EAAA,GAAA,UAAA,GACHC,IAAAA,EAAU,KAAKN,OAA3BC,GACJK,GAA0B,IAAjBA,EAAMC,QAGpBD,EAAME,IAAI,SAACC,GAEAA,OADPA,EAAIP,KAAKQ,MAAMD,EAAIN,QAASE,GACrBI,MA0Dd,CAAA,IAAA,MAzCGR,MAAAA,SAAAA,EAAWC,GACUI,IAAAA,EAAU,KAAKN,OAA3BC,GACJK,IAIAN,KAAAA,OAAOC,GAAaK,EAAMK,YAAY,SAACC,EAAMC,GAIvCD,OAHHC,EAAQX,OAASA,GACjBU,EAAKR,KAAKS,GAEPD,GACR,OA8BN,CAAA,IAAA,QAjBKX,MAAAA,SAAAA,GACG,KAAKD,OAAOC,KAGZD,KAAAA,OAAOC,GAAa,MAa5B,CAAA,IAAA,WAFU,MAAA,WACFD,KAAAA,OAAS,OACjB,EAAA,GAAA,QAAA,QAAA","file":"index.umd.map","sourceRoot":"../src","sourcesContent":["/**\n * @class EventBus\n * @description Simple library to trigger custom events\n * @example\n * import EventBus from '@docomodigital/js-eventbus';\n *\n * const Bus = new EventBus();\n * const callback = (args) => {\n *   // Do something...\n * };\n *\n * Bus.on('customEvent', callback);\n * Bus.trigger('customEvent', {foo: 'bar'}); // callback is called\n */\nexport default class EventBus {\n    constructor() {\n        this.events = {};\n    }\n\n    /**\n     * @memberOf EventBus\n     * @function on\n     * @description Register a new callback for the specified custom event\n     * @param {String} eventType - if not exists it defines a new one\n     * @param {Function} func - the function to call when the event is triggered\n     * @param {Object} [context=null] - the 'this' applied to the function. default null,\n     * this will not work with arrow functions.\n     * @return {void}\n     * @example\n     * const Bus = new EventBus();\n     * Bus.on('customEvent', (args) => {\n     *     // Do something...\n     * });\n     *\n     * const ctx = {foo: 'bar'}\n     * Bus.on('customEvent', (args) => {\n     *     console.log(this.foo) // Uncaught TypeError: Cannot read property 'foo' of undefined\n     * }, ctx);\n     * Bus.on('customEvent', function(args) {\n     *     console.log(this.foo) // 'bar'\n     * }, ctx);\n     */\n    on(eventType, func, context = null) {\n        if (!this.events[eventType]) {\n            this.events[eventType] = [];\n        }\n        this.events[eventType].push({ func, context });\n    }\n\n    /**\n     * @memberOf EventBus\n     * @function trigger\n     * @description Trigger the specified event, pass the other arguments to the callbacks\n     * @param {String} eventType - the eventType to trigger. if not exists nothing happens\n     * @param {*} args - Arguments to pass to the eventType callbacks\n     * @return {void}\n     * @example\n     * const Bus = new EventBus();\n     * const cb = (args) => {}\n     * Bus.on('customEvent', cb);\n     * Bus.trigger('customEvent'); //cb is called\n     */\n    trigger(eventType, ...args) {\n        const { [eventType]: event } = this.events;\n        if (!event || event.length === 0) {\n            return;\n        }\n        event.map((obj) => {\n            obj.func.apply(obj.context, args);\n            return obj;\n        });\n    }\n\n    /**\n     * @memberOf EventBus\n     * @function off\n     * @description Remove the specified callback from the specified event\n     * @param {String} eventType - the eventType\n     * @param {Function} func - the reference of the function to remove from the list of function\n     * @return {void}\n     * @example\n     *const cb = (args) => {};\n     * Bus.on('evt', cb);\n     * Bus.off('evt', cb);\n     * Bus.trigger('evt') // cb is not called\n     */\n    off(eventType, func) {\n        const { [eventType]: event } = this.events;\n        if (!event) {\n            return;\n        }\n\n        this.events[eventType] = event.reduceRight((prev, current) => {\n            if (current.func !== func) {\n                prev.push(current);\n            }\n            return prev;\n        }, []);\n    }\n\n    /**\n     * @memberOf EventBus\n     * @function clear\n     * @description Remove all the callbacks from the specified event\n     * if the event not exists nothing happens\n     * @param {String} eventType - the event type to clear\n     * @return {void}\n     * @example\n     * Bus.clear('evt');\n     */\n    clear(eventType) {\n        if (!this.events[eventType]) {\n            return;\n        }\n        this.events[eventType] = [];\n    }\n\n    /**\n     * @memberOf EventBus\n     * @function clearAll\n     * @description Remove all the callbacks from all the events\n     * @return {void}\n     * @example\n     * Bus.clearAll();\n     */\n    clearAll() {\n        this.events = {};\n    }\n}"]}